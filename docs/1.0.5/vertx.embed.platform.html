<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>vertx.embed.platform documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Vert.x clojure language module  API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="vertx.buffer.html"><span>vertx.buffer</span></a></li><li><a href="vertx.core.html"><span>vertx.core</span></a></li><li><a href="vertx.datagram.html"><span>vertx.datagram</span></a></li><li><a href="vertx.dns.html"><span>vertx.dns</span></a></li><li><a href="vertx.embed.html"><span>vertx.embed</span></a></li><li class="current"><a href="vertx.embed.platform.html"><span>vertx.embed.platform</span></a></li><li><a href="vertx.eventbus.html"><span>vertx.eventbus</span></a></li><li><a href="vertx.filesystem.html"><span>vertx.filesystem</span></a></li><li><a href="vertx.filesystem.sync.html"><span>vertx.filesystem.sync</span></a></li><li><a href="vertx.http.html"><span>vertx.http</span></a></li><li><a href="vertx.http.route.html"><span>vertx.http.route</span></a></li><li><a href="vertx.http.sockjs.html"><span>vertx.http.sockjs</span></a></li><li><a href="vertx.http.websocket.html"><span>vertx.http.websocket</span></a></li><li><a href="vertx.logging.html"><span>vertx.logging</span></a></li><li><a href="vertx.net.html"><span>vertx.net</span></a></li><li><a href="vertx.repl.html"><span>vertx.repl</span></a></li><li><a href="vertx.shareddata.html"><span>vertx.shareddata</span></a></li><li><a href="vertx.stream.html"><span>vertx.stream</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="vertx.embed.platform.html#var-deploy-module"><span class="">deploy-module</span></a></li><li><a href="vertx.embed.platform.html#var-deploy-module-from-classpath"><span class="">deploy-module-from-classpath</span></a></li><li><a href="vertx.embed.platform.html#var-deploy-module-from-zip"><span class="">deploy-module-from-zip</span></a></li><li><a href="vertx.embed.platform.html#var-deploy-verticle"><span class="">deploy-verticle</span></a></li><li><a href="vertx.embed.platform.html#var-deploy-worker-verticle"><span class="">deploy-worker-verticle</span></a></li><li><a href="vertx.embed.platform.html#var-install-module"><span class="">install-module</span></a></li><li><a href="vertx.embed.platform.html#var-instances"><span class="">instances</span></a></li><li><a href="vertx.embed.platform.html#var-make-fat-jar"><span class="">make-fat-jar</span></a></li><li><a href="vertx.embed.platform.html#var-on-exit"><span class="">on-exit</span></a></li><li><a href="vertx.embed.platform.html#var-platform-manager"><span class="">platform-manager</span></a></li><li><a href="vertx.embed.platform.html#var-pull-in-dependencies"><span class="">pull-in-dependencies</span></a></li><li><a href="vertx.embed.platform.html#var-undeploy"><span class="">undeploy</span></a></li><li><a href="vertx.embed.platform.html#var-undeploy-all"><span class="">undeploy-all</span></a></li><li><a href="vertx.embed.platform.html#var-uninstall-module"><span class="">uninstall-module</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>vertx.embed.platform documentation</h2><pre class="doc">Functions for running Vert.x embedded with a platform manager.
</pre><div class="public " id="var-deploy-module"><h3>deploy-module</h3><div class="usage"><code>(deploy-module platform-manager module-name &amp; {:keys [config instances ha? handler], :or {config {}, instances 1}})</code></div><pre class="doc">Deploys the module with the given name to platform-manager.

Takes the following keyword arguments [default]:

:config     A configuration map for the module [{}]
:ha?        If true then the module is enabled for ha and will
            failover to any other vert.x instances with the
            same group in the cluster [false]
:handler    Either be a two-arity fn that will be passed
            the exception-map (if any) and module id from the
            result of the deploy call, or a
            org.vertx.java.core.Handler that will be
            called with the AsyncResult object that wraps
            the exception and id [nil]
:instances  The number of instances of the module to
            deploy [1]</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L101">Source</a></div></div><div class="public " id="var-deploy-module-from-classpath"><h3>deploy-module-from-classpath</h3><div class="usage"><code>(deploy-module-from-classpath platform-manager module-name &amp; {:keys [classpath config instances handler], :or {config {}, instances 1}})</code></div><pre class="doc">Deploys a module from the classpath to platform-manager.
The classpath must contain a single mod.json and the resources for
that module only.

Takes the following keyword arguments [default]:

:classpath  The classpath to use for the verticle as a
            sequence of URLs ['()]
:config     A configuration map for the module [{}]
:handler    Either be a two-arity fn that will be passed
            the exception-map (if any) and module id from the
            result of the deploy call, or a
            org.vertx.java.core.Handler that will be
            called with the AsyncResult object that wraps
            the exception and id [nil]
:instances  The number of instances of the module to
            deploy [1]</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L158">Source</a></div></div><div class="public " id="var-deploy-module-from-zip"><h3>deploy-module-from-zip</h3><div class="usage"><code>(deploy-module-from-zip platform-manager zip-file-path &amp; {:keys [config instances handler], :or {config {}, instances 1}})</code></div><pre class="doc">Deploys the module from the given zip file to platform-manager.
The zip must contain a valid Vert.x module. Vert.x will
automatically install the module from the zip into the local mods
dir or the system mods dir (if it's a system module), or VERTX_MODS
if set, and then deploy the module.

Takes the following keyword arguments [default]:

:config     A configuration map for the module [{}]
:ha?        If true then the module is enabled for ha and will
            failover to any other vert.x instances with the
            same group in the cluster [false]
:handler    Either be a two-arity fn that will be passed
            the exception-map (if any) and module id from the
            result of the deploy call, or a
            org.vertx.java.core.Handler that will be
            called with the AsyncResult object that wraps
            the exception and id [nil]
:instances  The number of instances of the module to
            deploy [1]</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L128">Source</a></div></div><div class="public " id="var-deploy-verticle"><h3>deploy-verticle</h3><div class="usage"><code>(deploy-verticle platform-manager main &amp; {:keys [config classpath instances includes handler], :or {config {}, instances 1}})</code></div><pre class="doc">Deploys the verticle with the given main file path using platform-manager.
main must be on the effective classpath.

Takes the following keyword arguments [default]:

:classpath  The classpath to use for the verticle as a
            sequence of URLs ['()]
:config     A configuration map for the verticle [{}]
:handler    Either be a two-arity fn that will be passed
            the exception (if any) and verticle id from the
            result of the deploy call, or a
            org.vertx.java.core.Handler that will be
            called with the AsyncResult object that wraps
            the exception and id [nil]
:includes   A sequence of modules to include [nil]
:instances  The number of instances of the verticle to
            deploy [1]</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L40">Source</a></div></div><div class="public " id="var-deploy-worker-verticle"><h3>deploy-worker-verticle</h3><div class="usage"><code>(deploy-worker-verticle platform-manager main &amp; {:keys [classpath config instances includes multi-threaded? handler], :or {config {}, instances 1}})</code></div><pre class="doc">Deploys the worker verticle with the given main file path using platform-manager.
main must be on the effective classpath.

Takes the following keyword arguments [default]:

:classpath        The classpath to use for the verticle as a
                  sequence of URLs ['()]
:config           A configuration map for the verticle [{}]
:handler          Either be a two-arity fn that will be passed
                  the exception-map (if any) and verticle id from the
                  result of the deploy call, or a
                  org.vertx.java.core.Handler that will be
                  called with the AsyncResult object that wraps
                  the exception and id [nil]
:includes         A sequence of modules to include [nil]
:instances        The number of instances of the verticle to
                  deploy [1]
:multi-threaded?  When true, the verticle will be accessed
                  by multiple threads concurrently [false]</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L69">Source</a></div></div><div class="public " id="var-install-module"><h3>install-module</h3><div class="usage"><code>(install-module platform-manager module-name)</code><code>(install-module platform-manager module-name handler)</code></div><pre class="doc">Downloads and installs the named module locally.
handler can either be a single-arity fn that will be passed the
exception (if any) from the result of the install call, or a
org.vertx.java.core.Handler that will be called with the
AsyncResult object that wraps the exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L215">Source</a></div></div><div class="public " id="var-instances"><h3>instances</h3><div class="usage"><code>(instances platform-manager)</code></div><pre class="doc">Returns a map of deployment ids to number of instances.
</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L210">Source</a></div></div><div class="public " id="var-make-fat-jar"><h3>make-fat-jar</h3><div class="usage"><code>(make-fat-jar platform-manager module-name output-dir)</code><code>(make-fat-jar platform-manager module-name output-dir handler)</code></div><pre class="doc">Create a fat executable jar which includes the Vert.x binaries and
the module so it can be run directly with java without having to
pre-install Vert.x. e.g.: java -jar mymod~1.0-fat.jar
handler can either be a single-arity fn that will be passed the
exception (if any) from the result of the call, or a
org.vertx.java.core.Handler that will be called with the
AsyncResult object that wraps the exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L253">Source</a></div></div><div class="public " id="var-on-exit"><h3>on-exit</h3><div class="usage"><code>(on-exit platform-manager handler)</code></div><pre class="doc">Register a handler that will be called when the platform exits.
handler can either be a zero-arity fn or a Handler instance.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L267">Source</a></div></div><div class="public " id="var-platform-manager"><h3>platform-manager</h3><div class="usage"><code>(platform-manager)</code><code>(platform-manager cluster-port cluster-host)</code><code>(platform-manager cluster-port cluster-host quorum-size ha-group)</code></div><pre class="doc">Creates a platform manager.
cluster-port and cluster-host specify the port and host to use for
clustering, respectively. If not provided, clustering is disabled.
quorum-size specify the minimum number of nodes in the cluster
before deployments in this platform manager will be activated. If
not provided, ha is disabled. ha-group specifies the group name in
which this platform manager participates. If nil, &quot;__DEFAULT__&quot;
is used.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L23">Source</a></div></div><div class="public " id="var-pull-in-dependencies"><h3>pull-in-dependencies</h3><div class="usage"><code>(pull-in-dependencies platform-manager module-name)</code><code>(pull-in-dependencies platform-manager module-name handler)</code></div><pre class="doc">Pull in all the dependencies (the 'includes' and the 'deploys'
fields in mod.json) and copy them into an internal mods directory
in the module. This allows a self contained module to be created.
handler can either be a single-arity fn that will be passed the
exception (if any) from the result of the call, or a
org.vertx.java.core.Handler that will be called with the
AsyncResult object that wraps the exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L239">Source</a></div></div><div class="public " id="var-undeploy"><h3>undeploy</h3><div class="usage"><code>(undeploy platform-manager id)</code><code>(undeploy platform-manager id handler)</code></div><pre class="doc">Undeploys the deployment identified by id from platform-manager.
handler can either be a single-arity fn that will be passed the
exception (if any) from the result of the undeploy call, or a
org.vertx.java.core.Handler that will be called with the
AsyncResult object that wraps the exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L186">Source</a></div></div><div class="public " id="var-undeploy-all"><h3>undeploy-all</h3><div class="usage"><code>(undeploy-all platform-manager)</code><code>(undeploy-all platform-manager handler)</code></div><pre class="doc">Undeploys the all deployments from platform-manager.
handler can either be a single-arity fn that will be passed the
exception (if any) from the result of the undeploy call, or a
org.vertx.java.core.Handler that will be called with the
AsyncResult object that wraps the exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L198">Source</a></div></div><div class="public " id="var-uninstall-module"><h3>uninstall-module</h3><div class="usage"><code>(uninstall-module platform-manager module-name)</code><code>(uninstall-module platform-manager module-name handler)</code></div><pre class="doc">Removes the module from the local installation.
handler can either be a single-arity fn that will be passed the
exception (if any) from the result of the uninstall call, or a
org.vertx.java.core.Handler that will be called with the
AsyncResult object that wraps the exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/embed/platform.clj#L227">Source</a></div></div></div></body></html>