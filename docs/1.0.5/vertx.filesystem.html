<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>vertx.filesystem documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Vert.x clojure language module  API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="vertx.buffer.html"><span>vertx.buffer</span></a></li><li><a href="vertx.core.html"><span>vertx.core</span></a></li><li><a href="vertx.datagram.html"><span>vertx.datagram</span></a></li><li><a href="vertx.dns.html"><span>vertx.dns</span></a></li><li><a href="vertx.embed.html"><span>vertx.embed</span></a></li><li><a href="vertx.embed.platform.html"><span>vertx.embed.platform</span></a></li><li><a href="vertx.eventbus.html"><span>vertx.eventbus</span></a></li><li class="current"><a href="vertx.filesystem.html"><span>vertx.filesystem</span></a></li><li><a href="vertx.filesystem.sync.html"><span>vertx.filesystem.sync</span></a></li><li><a href="vertx.http.html"><span>vertx.http</span></a></li><li><a href="vertx.http.route.html"><span>vertx.http.route</span></a></li><li><a href="vertx.http.sockjs.html"><span>vertx.http.sockjs</span></a></li><li><a href="vertx.http.websocket.html"><span>vertx.http.websocket</span></a></li><li><a href="vertx.logging.html"><span>vertx.logging</span></a></li><li><a href="vertx.net.html"><span>vertx.net</span></a></li><li><a href="vertx.repl.html"><span>vertx.repl</span></a></li><li><a href="vertx.shareddata.html"><span>vertx.shareddata</span></a></li><li><a href="vertx.stream.html"><span>vertx.stream</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="vertx.filesystem.html#var-*file-system*"><span class="">*file-system*</span></a></li><li><a href="vertx.filesystem.html#var-chmod"><span class="">chmod</span></a></li><li><a href="vertx.filesystem.html#var-chown"><span class="">chown</span></a></li><li><a href="vertx.filesystem.html#var-close"><span class="">close</span></a></li><li><a href="vertx.filesystem.html#var-copy"><span class="">copy</span></a></li><li><a href="vertx.filesystem.html#var-create-file"><span class="">create-file</span></a></li><li><a href="vertx.filesystem.html#var-delete"><span class="">delete</span></a></li><li><a href="vertx.filesystem.html#var-exists%3F"><span class="">exists?</span></a></li><li><a href="vertx.filesystem.html#var-file-system-properties"><span class="">file-system-properties</span></a></li><li><a href="vertx.filesystem.html#var-flush"><span class="">flush</span></a></li><li><a href="vertx.filesystem.html#var-get-file-system"><span class="">get-file-system</span></a></li><li><a href="vertx.filesystem.html#var-link"><span class="">link</span></a></li><li><a href="vertx.filesystem.html#var-mkdir"><span class="">mkdir</span></a></li><li><a href="vertx.filesystem.html#var-move"><span class="">move</span></a></li><li><a href="vertx.filesystem.html#var-open"><span class="">open</span></a></li><li><a href="vertx.filesystem.html#var-properties"><span class="">properties</span></a></li><li><a href="vertx.filesystem.html#var-read"><span class="">read</span></a></li><li><a href="vertx.filesystem.html#var-read-dir"><span class="">read-dir</span></a></li><li><a href="vertx.filesystem.html#var-read-file"><span class="">read-file</span></a></li><li><a href="vertx.filesystem.html#var-resolve-symlink"><span class="">resolve-symlink</span></a></li><li><a href="vertx.filesystem.html#var-truncate"><span class="">truncate</span></a></li><li><a href="vertx.filesystem.html#var-write"><span class="">write</span></a></li><li><a href="vertx.filesystem.html#var-write-file"><span class="">write-file</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>vertx.filesystem documentation</h2><pre class="doc">Provides a broad set of functions for manipulating files. Wraps the
asynchronous methods from org.vertx.java.core.file.FileSystem.</pre><div class="public " id="var-*file-system*"><h3>*file-system*</h3><h4 class="type">var</h4><div class="usage"></div><pre class="doc">The currently active default vertx container instance.
If not bound, the FileSystem from vertx.core/*vertx* will be used.
You should only need to bind this for advanced usage.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L23">Source</a></div></div><div class="public " id="var-chmod"><h3>chmod</h3><div class="usage"><code>(chmod path perms handler)</code><code>(chmod path perms dir-perms handler)</code></div><pre class="doc">Change the permissions on the file represented path to perms, asynchronously.
If dir-perms is provided and path is a directory, it will have its
permisions changed recursively, with perms being applied to any
files, and dir-perms being applied to directories. handler can
either be a single-arity fn that will be passed the exception-map (if
any) from the result of the call, or a Handler that will be called
with the AsyncResult object that wraps the exception.

The permission strings take the form rwxr-x--- as specified by
http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L76">Source</a></div></div><div class="public " id="var-chown"><h3>chown</h3><div class="usage"><code>(chown path user handler)</code><code>(chown path user group handler)</code></div><pre class="doc">Changes the ownership on the file at path to user and group, asynchronously.
handler can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the call, or a Handler that
will be called with the AsyncResult object that wraps the
exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L94">Source</a></div></div><div class="public " id="var-close"><h3>close</h3><div class="usage"><code>(close file)</code><code>(close file handler)</code></div><pre class="doc">Close the file, asynchronously.
handler can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the call, or a Handler that
will be called with the AsyncResult object that wraps the
exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L340">Source</a></div></div><div class="public " id="var-copy"><h3>copy</h3><div class="usage"><code>(copy src dest handler)</code><code>(copy src dest recursive? handler)</code></div><pre class="doc">Copy a file from the src path to dest path, asynchronously.
If recursive? is true and src represents a directory, then the
directory and its contents will be copied recursively to
dest. recursive? defaults to false. handler can either be a
single-arity fn that will be passed the exception-map (if any) from the
result of the copy call, or a Handler that will be called with the
AsyncResult object that wraps the exception.

The copy will fail if the destination already exists.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L34">Source</a></div></div><div class="public " id="var-create-file"><h3>create-file</h3><div class="usage"><code>(create-file path handler)</code><code>(create-file path perms handler)</code></div><pre class="doc">Creates an empty file with the specified path, asynchronously.
If perms are provided, they will override the default permissions
for the created file. The permission String takes the form
rwxr-x--- as specified by:
http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html
handler can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the call, or a Handler that
will be called with the AsyncResult object that wraps the
exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L265">Source</a></div></div><div class="public " id="var-delete"><h3>delete</h3><div class="usage"><code>(delete path handler)</code><code>(delete path recursive? handler)</code></div><pre class="doc">Deletes the file on the file system represented by path, asynchronously.
handler can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the call, or a Handler that
will be called with the AsyncResult object that wraps the
exception.

If the recursive? is true (default is false) and file is a
directory, it will be deleted recursively.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L165">Source</a></div></div><div class="public " id="var-exists%3F"><h3>exists?</h3><div class="usage"><code>(exists? path handler)</code></div><pre class="doc">Determines whether the file as specified by the path {@code path} exists, asynchronously.
handler can either be a two-arity fn that will be passed the
exception-map (if any) and the boolean result of the call, or a Handler
that will be called with the AsyncResult object that wraps the
exception and the boolean result.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L281">Source</a></div></div><div class="public " id="var-file-system-properties"><h3>file-system-properties</h3><div class="usage"><code>(file-system-properties path handler)</code></div><pre class="doc">Returns properties of the file-system being used by the specified path, asynchronously.
handler can either be a two-arity fn that will be passed the
exception-map (if any) and properties (as a map) from the result of the
call, or a Handler that will be called with the AsyncResult object
that wraps the exception and FileSystemProps object.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L297">Source</a></div></div><div class="public " id="var-flush"><h3>flush</h3><div class="usage"><code>(flush file)</code><code>(flush file handler)</code></div><pre class="doc">Flush any writes made to this file to underlying persistent storage, asynchronously.
handler can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the call, or a Handler that
will be called with the AsyncResult object that wraps the
exception.

If the file was opened with :flush? true, then calling this method
will have no effect.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L351">Source</a></div></div><div class="public " id="var-get-file-system"><h3>get-file-system</h3><div class="usage"><code>(get-file-system)</code></div><pre class="doc">Returns the currently active FileSystem instance.
</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L29">Source</a></div></div><div class="public " id="var-link"><h3>link</h3><div class="usage"><code>(link path existing handler)</code><code>(link path existing symbolic? handler)</code></div><pre class="doc">Creates a link on the file system from path to existing, asynchronously.
If symbolic? is true (the default), the resulting link is symbolic,
otherwise a had link is created. handler can either be a
single-arity fn that will be passed the exception-map (if any) from the
result of the call, or a Handler that will be called with the
AsyncResult object that wraps the exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L139">Source</a></div></div><div class="public " id="var-mkdir"><h3>mkdir</h3><div class="usage"><code>(mkdir path handler)</code><code>(mkdir path create-parents? handler)</code><code>(mkdir path create-parents? perms handler)</code></div><pre class="doc">Create the directory represented by path, asynchronously.
If create-parents? is true (default is false), any non-existent
parent directories of the directory will also be created.  If perms
are provided, they will override the default permissions for the
created directory.  The permission String takes the form rwxr-x---
as specified by:
http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html
handler can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the call, or a Handler that
will be called with the AsyncResult object that wraps the
exception.

The operation will fail if the directory already exists.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L180">Source</a></div></div><div class="public " id="var-move"><h3>move</h3><div class="usage"><code>(move src dest handler)</code></div><pre class="doc">Move a file from the src path to dest path, asynchronously.
handler can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the move call, or a Handler
that will be called with the AsyncResult object that wraps the
exception.

The move will fail if the destination already exists.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L51">Source</a></div></div><div class="public " id="var-open"><h3>open</h3><div class="usage"><code>(open path handler &amp; {:keys [perms read? write? create? flush?], :or {read? true, write? true, create? true}})</code></div><pre class="doc">Open the file represented by path, asynchronously.
handler can either be a two-arity fn that will be passed the
exception-map (if any) and the AsyncFile instance from the result of
the call, or a Handler that will be called with the AsyncResult
object that wraps the exception and the buffer.

The behavior of the open call is further controlled by a set of
keyword arguments [default]:

* :create? - create the file if it does not already exist [true]
* :read?   - open the file for reading [true]
* :write?  - open the file for writing [true]
* :flush?  - the opened file will auto-flush writes [false]
* :perms   - the permissions used to create the file, if necessary
             (see create-file) [nil]</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L240">Source</a></div></div><div class="public " id="var-properties"><h3>properties</h3><div class="usage"><code>(properties path handler)</code><code>(properties path follow-link? handler)</code></div><pre class="doc">Obtain properties for the file represented by path, asynchronously.
handler can either be a two-arity fn that will be passed the
exception-map (if any) and properties (as a map) from the result of the
call, or a Handler that will be called with the AsyncResult object
that wraps the exception and FileProps object.

The properties map passed to the handler fn will
contain :creation-time, :last-access-time, :last-modified-time,
:directory?, :regular-file?, :symbolic-link?, :other?, and :size.

If the follow-link? is true (the default) and file is a link, the
link will be followed.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L117">Source</a></div></div><div class="public " id="var-read"><h3>read</h3><div class="usage"><code>(read file pos length handler)</code><code>(read file buffer! offset pos length handler)</code></div><pre class="doc">Reads length bytes of data from the file at position pos in the file, asynchronously.
If provided, the read data will be written into buffer! at offset.
handler can either be a two-arity fn that will be passed the
exception-map (if any) and the Buffer from the result of the
call, or a Handler that will be called with the AsyncResult object
that wraps the exception and Buffer object.

If data is read past the end of the file then zero bytes will be
read. When multiple reads are invoked on the same file there are no
guarantees as to order in which those reads actually occur.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L323">Source</a></div></div><div class="public " id="var-read-dir"><h3>read-dir</h3><div class="usage"><code>(read-dir path handler)</code><code>(read-dir path filter handler)</code></div><pre class="doc">Read the contents of the directory specified by path, asynchronously.
If a filter regex is specified then only the paths that match it
will be returned. handler can either be a two-arity fn that will be
passed the exception-map (if any) and a vector of String paths from the
result of the call, or a Handler that will be called with the
AsyncResult object that wraps the exception and a String[] of
paths.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L202">Source</a></div></div><div class="public " id="var-read-file"><h3>read-file</h3><div class="usage"><code>(read-file path handler)</code></div><pre class="doc">Reads the entire file as represented by the path path as a Buffer, asynchronously.
handler can either be a two-arity fn that will be passed the
exception-map (if any) and the Buffer from the result of the call, or a
Handler that will be called with the AsyncResult object that wraps
the exception and the buffer.

Do not user this method to read very large files or you
risk running out of available RAM.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L216">Source</a></div></div><div class="public " id="var-resolve-symlink"><h3>resolve-symlink</h3><div class="usage"><code>(resolve-symlink path handler)</code></div><pre class="doc">Returns the path representing the file that the symbolic link specified by path points to, asynchronously.
handler can either be a two-arity fn that will be passed the
exception-map (if any) and the String path from the result of the call,
or a Handler that will be called with the AsyncResult object that
wraps the exception and the String path.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L155">Source</a></div></div><div class="public " id="var-truncate"><h3>truncate</h3><div class="usage"><code>(truncate path len handler)</code></div><pre class="doc">Truncate the file represented by path to length len in bytes, asynchronously.
handler can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the truncate call, or a
Handler that will be called with the AsyncResult object that wraps
the exception.

The truncate will fail if the file does not exist or len is less
than zero.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L63">Source</a></div></div><div class="public " id="var-write"><h3>write</h3><div class="usage"><code>(write file data pos handler)</code></div><pre class="doc">Write data to the file at position pos in the file, asynchronously.
data can anything bufferable (see vertx.buffer).  If pos
lies outside of the current size of the file, the file will be
enlarged to encompass it. handler can either be a single-arity fn
that will be passed the exception-map (if any) from the result of the
call, or a Handler that will be called with the AsyncResult object
that wraps the exception.  

When multiple writes are invoked on the same file there are no
guarantees as to the order in which those writes actually occur.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L308">Source</a></div></div><div class="public " id="var-write-file"><h3>write-file</h3><div class="usage"><code>(write-file path data handler)</code></div><pre class="doc">Creates the file, and writes the specified data to the file represented by path, asynchronously.
data can anything bufferable (see vertx.buffer).  handler
can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the call, or a Handler that
will be called with the AsyncResult object that wraps the
exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/filesystem.clj#L229">Source</a></div></div></div></body></html>