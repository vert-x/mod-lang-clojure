<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>vertx.http.route documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Vert.x clojure language module  API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="vertx.buffer.html"><span>vertx.buffer</span></a></li><li><a href="vertx.core.html"><span>vertx.core</span></a></li><li><a href="vertx.datagram.html"><span>vertx.datagram</span></a></li><li><a href="vertx.dns.html"><span>vertx.dns</span></a></li><li><a href="vertx.embed.html"><span>vertx.embed</span></a></li><li><a href="vertx.embed.platform.html"><span>vertx.embed.platform</span></a></li><li><a href="vertx.eventbus.html"><span>vertx.eventbus</span></a></li><li><a href="vertx.filesystem.html"><span>vertx.filesystem</span></a></li><li><a href="vertx.filesystem.sync.html"><span>vertx.filesystem.sync</span></a></li><li><a href="vertx.http.html"><span>vertx.http</span></a></li><li class="current"><a href="vertx.http.route.html"><span>vertx.http.route</span></a></li><li><a href="vertx.http.sockjs.html"><span>vertx.http.sockjs</span></a></li><li><a href="vertx.http.websocket.html"><span>vertx.http.websocket</span></a></li><li><a href="vertx.logging.html"><span>vertx.logging</span></a></li><li><a href="vertx.net.html"><span>vertx.net</span></a></li><li><a href="vertx.repl.html"><span>vertx.repl</span></a></li><li><a href="vertx.shareddata.html"><span>vertx.shareddata</span></a></li><li><a href="vertx.stream.html"><span>vertx.stream</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="vertx.http.route.html#var-all"><span class="">all</span></a></li><li><a href="vertx.http.route.html#var-connect"><span class="">connect</span></a></li><li><a href="vertx.http.route.html#var-delete"><span class="">delete</span></a></li><li><a href="vertx.http.route.html#var-get"><span class="">get</span></a></li><li><a href="vertx.http.route.html#var-head"><span class="">head</span></a></li><li><a href="vertx.http.route.html#var-matcher"><span class="">matcher</span></a></li><li><a href="vertx.http.route.html#var-no-match"><span class="">no-match</span></a></li><li><a href="vertx.http.route.html#var-options"><span class="">options</span></a></li><li><a href="vertx.http.route.html#var-patch"><span class="">patch</span></a></li><li><a href="vertx.http.route.html#var-post"><span class="">post</span></a></li><li><a href="vertx.http.route.html#var-put"><span class="">put</span></a></li><li><a href="vertx.http.route.html#var-trace"><span class="">trace</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>vertx.http.route documentation</h2><pre class="doc">Functions for operating on Vertx.x RouteMatcher.
RouteMatchers allows you to do route requests based on the HTTP
verb and the request URI, in a manner similar Sinatra or Express.

RouteMatchers also let you extract parameters from the request URI
either a via simple pattern or using regular expressions for more
complex matches. Any parameters extracted will be added to the
requests parameters which will be available to you in your request
handler.</pre><div class="public " id="var-all"><h3>all</h3><div class="usage"><code>(all pattern handler)</code><code>(all matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP ALL.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP ALL. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L73">Source</a></div></div><div class="public " id="var-connect"><h3>connect</h3><div class="usage"><code>(connect pattern handler)</code><code>(connect matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP CONNECT.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP CONNECT. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L70">Source</a></div></div><div class="public " id="var-delete"><h3>delete</h3><div class="usage"><code>(delete pattern handler)</code><code>(delete matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP DELETE.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP DELETE. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L67">Source</a></div></div><div class="public " id="var-get"><h3>get</h3><div class="usage"><code>(get pattern handler)</code><code>(get matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP GET.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP GET. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L64">Source</a></div></div><div class="public " id="var-head"><h3>head</h3><div class="usage"><code>(head pattern handler)</code><code>(head matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP HEAD.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP HEAD. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L68">Source</a></div></div><div class="public " id="var-matcher"><h3>matcher</h3><div class="usage"><code>(matcher)</code></div><pre class="doc">Create a RouteMatcher instance.
</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L30">Source</a></div></div><div class="public " id="var-no-match"><h3>no-match</h3><div class="usage"><code>(no-match handler)</code><code>(no-match matcher handler)</code></div><pre class="doc">Specify a handler that will be called when no other handlers match.
handler can either be a single-arity fn or a Handler instance that
will be called with the HttpServerRequest object If this handler is
not specified. Default behaviour is to return a 404.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L75">Source</a></div></div><div class="public " id="var-options"><h3>options</h3><div class="usage"><code>(options pattern handler)</code><code>(options matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP OPTIONS.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP OPTIONS. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L69">Source</a></div></div><div class="public " id="var-patch"><h3>patch</h3><div class="usage"><code>(patch pattern handler)</code><code>(patch matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP PATCH.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP PATCH. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L72">Source</a></div></div><div class="public " id="var-post"><h3>post</h3><div class="usage"><code>(post pattern handler)</code><code>(post matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP POST.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP POST. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L66">Source</a></div></div><div class="public " id="var-put"><h3>put</h3><div class="usage"><code>(put pattern handler)</code><code>(put matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP PUT.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP PUT. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L65">Source</a></div></div><div class="public " id="var-trace"><h3>trace</h3><div class="usage"><code>(trace pattern handler)</code><code>(trace matcher pattern handler)</code></div><pre class="doc">Specify a handler that will be called for a matching HTTP TRACE.

If no matcher is provided, a new one will be created. pattern can
either be a simple pattern or regular expression. handler can
either be a single-arity fn or a Handler instance that will be
called with the HttpServerRequest object.

To use a simple pattern to extract parameters simply prefix the
parameter name in the pattern with a ':' (colon) For more complex
matches regular expressions can be used in the pattern. When
regular expressions are used, the extracted parameters do not
have a name, so they are put into the HTTP request with names of
param0, param1, param2 etc. Multiple matches can be specified
for each HTTP TRACE. In the case there are more than one matching
patterns for a particular request, the first matching one will be
used.  Returns the matcher.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http/route.clj#L71">Source</a></div></div></div></body></html>