<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>vertx.datagram documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Vert.x clojure language module  API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="vertx.buffer.html"><span>vertx.buffer</span></a></li><li><a href="vertx.core.html"><span>vertx.core</span></a></li><li class="current"><a href="vertx.datagram.html"><span>vertx.datagram</span></a></li><li><a href="vertx.dns.html"><span>vertx.dns</span></a></li><li><a href="vertx.embed.html"><span>vertx.embed</span></a></li><li><a href="vertx.embed.platform.html"><span>vertx.embed.platform</span></a></li><li><a href="vertx.eventbus.html"><span>vertx.eventbus</span></a></li><li><a href="vertx.filesystem.html"><span>vertx.filesystem</span></a></li><li><a href="vertx.filesystem.sync.html"><span>vertx.filesystem.sync</span></a></li><li><a href="vertx.http.html"><span>vertx.http</span></a></li><li><a href="vertx.http.route.html"><span>vertx.http.route</span></a></li><li><a href="vertx.http.sockjs.html"><span>vertx.http.sockjs</span></a></li><li><a href="vertx.http.websocket.html"><span>vertx.http.websocket</span></a></li><li><a href="vertx.logging.html"><span>vertx.logging</span></a></li><li><a href="vertx.net.html"><span>vertx.net</span></a></li><li><a href="vertx.repl.html"><span>vertx.repl</span></a></li><li><a href="vertx.shareddata.html"><span>vertx.shareddata</span></a></li><li><a href="vertx.stream.html"><span>vertx.stream</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="vertx.datagram.html#var-block-multicast-sender"><span class="">block-multicast-sender</span></a></li><li><a href="vertx.datagram.html#var-close"><span class="">close</span></a></li><li><a href="vertx.datagram.html#var-join-multicast-group"><span class="">join-multicast-group</span></a></li><li><a href="vertx.datagram.html#var-leave-multicast-group"><span class="">leave-multicast-group</span></a></li><li><a href="vertx.datagram.html#var-listen"><span class="">listen</span></a></li><li><a href="vertx.datagram.html#var-local-address"><span class="">local-address</span></a></li><li><a href="vertx.datagram.html#var-on-data"><span class="">on-data</span></a></li><li><a href="vertx.datagram.html#var-send"><span class="">send</span></a></li><li><a href="vertx.datagram.html#var-socket"><span class="">socket</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>vertx.datagram documentation</h2><pre class="doc">Provides a broad set of functions for UDP servers and clients.

Usually you use a Datragram Client to send UDP over the wire. UDP
is connection-less which means you are not connected to the remote
peer in a persistent way. Because of this you have to supply the
address and port of the remote peer when sending data.

You can send data to ipv4 or ipv6 addresses, which also include
multicast addresses.</pre><div class="public " id="var-block-multicast-sender"><h3>block-multicast-sender</h3><div class="usage"><code>(block-multicast-sender socket group-address source-address)</code><code>(block-multicast-sender socket group-address source-address handler)</code><code>(block-multicast-sender socket group-address source-address interface handler)</code></div><pre class="doc">Blocks packets from the given source-address for the given group.
interface can be used to limit the block to a specific interface.

handler can either be a two-arity fn that will be passed the
exception-map (if any) and socket from the result of the block
call, or a Handler instance that will be called with the
AsyncResult object that wraps the exception and socket. Returns the
socket instance.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/datagram.clj#L141">Source</a></div></div><div class="public " id="var-close"><h3>close</h3><div class="usage"><code>(close socket)</code><code>(close socket handler)</code></div><pre class="doc">Closes the socket.
handler can either be a single-arity fn that will be passed the
exception-map (if any) from the result of the close call, or a
Handler instance that will be called with the AsyncResult object
that wraps the exception.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/datagram.clj#L178">Source</a></div></div><div class="public " id="var-join-multicast-group"><h3>join-multicast-group</h3><div class="usage"><code>(join-multicast-group socket group-address)</code><code>(join-multicast-group socket group-address handler)</code><code>(join-multicast-group socket group-address interface handler)</code><code>(join-multicast-group socket group-address interface source-address handler)</code></div><pre class="doc">Joins the socket to a multicast group.
interface and source-address can be used to limit the packets
received to a particular interface and source address,
respectively.

handler can either be a two-arity fn that will be passed the
exception-map (if any) and socket from the result of the join
call, or a Handler instance that will be called with the
AsyncResult object that wraps the exception and socket. Returns the
socket instance.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/datagram.clj#L97">Source</a></div></div><div class="public " id="var-leave-multicast-group"><h3>leave-multicast-group</h3><div class="usage"><code>(leave-multicast-group socket group-address)</code><code>(leave-multicast-group socket group-address handler)</code><code>(leave-multicast-group socket group-address interface handler)</code><code>(leave-multicast-group socket group-address interface source handler)</code></div><pre class="doc">Removes the socket from a multicast group.
interface and source-address must be used if they were used as part
of the join.

handler can either be a two-arity fn that will be passed the
exception-map (if any) and socket from the result of the leave
call, or a Handler instance that will be called with the
AsyncResult object that wraps the exception and socket. Returns the
socket instance.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/datagram.clj#L120">Source</a></div></div><div class="public " id="var-listen"><h3>listen</h3><div class="usage"><code>(listen socket port)</code><code>(listen socket port host)</code><code>(listen socket port host handler)</code></div><pre class="doc">Makes socket listen to the given port and (optional) host.
handler can either be a two-arity fn that will be passed the
exception-map (if any) and socket from the result of the listen
call, or a Handler instance that will be called with the
AsyncResult object that wraps the exception and socket. Returns the
socket instance.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/datagram.clj#L81">Source</a></div></div><div class="public " id="var-local-address"><h3>local-address</h3><div class="usage"><code>(local-address socket)</code></div><pre class="doc">Returns the local address for the socket as an address-map.
This will be nil if listen hasn't been called for the socket.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/datagram.clj#L61">Source</a></div></div><div class="public " id="var-on-data"><h3>on-data</h3><div class="usage"><code>(on-data socket handler)</code></div><pre class="doc">Set a data handler on a socket.
As packets are read, the handler will be called with each packet of
the form:

  {:sender address-map
   :data data-as-a-buffer
   :basis the-DatagramPacket-object}

handler can either be a Handler or a single-arity fn.
Returns the socket.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/datagram.clj#L159">Source</a></div></div><div class="public " id="var-send"><h3>send</h3><div class="usage"><code>(send socket content host port)</code><code>(send socket content host port handler)</code></div><pre class="doc">Writes the given bufferable content to the given host &amp; port.
handler can either be a two-arity fn that will be passed the
exception-map (if any) and socket from the result of the send
call, or a Handler instance that will be called with the
AsyncResult object that wraps the exception and socket. Returns the
socket instance.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/datagram.clj#L67">Source</a></div></div><div class="public " id="var-socket"><h3>socket</h3><div class="usage"><code>(socket)</code><code>(socket protocol-family)</code><code>(socket protocol-family properties)</code></div><pre class="doc">Creates a datagram socket (DatagramSocket) instance using vertx.core/*vertx*.
protocol-family can be one of :ipv4, ipv6. properties is a map of
properties to set on the newly created socket instance. They are
translated into .setXXX calls by camel-casing the keyword
key. Example: {:send-buffer-size 1024} will trigger a call
to .setSendBufferSize on the socket object. See the docuementation
for org.vertx.java.core.datagram.DatagramSocket for a full list of
properties.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/datagram.clj#L42">Source</a></div></div></div></body></html>