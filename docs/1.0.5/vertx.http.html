<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>vertx.http documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Vert.x clojure language module  API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="vertx.buffer.html"><span>vertx.buffer</span></a></li><li><a href="vertx.core.html"><span>vertx.core</span></a></li><li><a href="vertx.datagram.html"><span>vertx.datagram</span></a></li><li><a href="vertx.dns.html"><span>vertx.dns</span></a></li><li><a href="vertx.embed.html"><span>vertx.embed</span></a></li><li><a href="vertx.embed.platform.html"><span>vertx.embed.platform</span></a></li><li><a href="vertx.eventbus.html"><span>vertx.eventbus</span></a></li><li><a href="vertx.filesystem.html"><span>vertx.filesystem</span></a></li><li><a href="vertx.filesystem.sync.html"><span>vertx.filesystem.sync</span></a></li><li class="current"><a href="vertx.http.html"><span>vertx.http</span></a></li><li><a href="vertx.http.route.html"><span>vertx.http.route</span></a></li><li><a href="vertx.http.sockjs.html"><span>vertx.http.sockjs</span></a></li><li><a href="vertx.http.websocket.html"><span>vertx.http.websocket</span></a></li><li><a href="vertx.logging.html"><span>vertx.logging</span></a></li><li><a href="vertx.net.html"><span>vertx.net</span></a></li><li><a href="vertx.repl.html"><span>vertx.repl</span></a></li><li><a href="vertx.shareddata.html"><span>vertx.shareddata</span></a></li><li><a href="vertx.stream.html"><span>vertx.stream</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="vertx.http.html#var-add-header"><span class="">add-header</span></a></li><li><a href="vertx.http.html#var-add-headers"><span class="">add-headers</span></a></li><li><a href="vertx.http.html#var-add-trailer"><span class="">add-trailer</span></a></li><li><a href="vertx.http.html#var-add-trailers"><span class="">add-trailers</span></a></li><li><a href="vertx.http.html#var-client"><span class="">client</span></a></li><li><a href="vertx.http.html#var-close"><span class="">close</span></a></li><li><a href="vertx.http.html#var-connect"><span class="">connect</span></a></li><li><a href="vertx.http.html#var-delete"><span class="">delete</span></a></li><li><a href="vertx.http.html#var-end"><span class="">end</span></a></li><li><a href="vertx.http.html#var-expect-multi-part"><span class="">expect-multi-part</span></a></li><li><a href="vertx.http.html#var-form-attributes"><span class="">form-attributes</span></a></li><li><a href="vertx.http.html#var-get"><span class="">get</span></a></li><li><a href="vertx.http.html#var-get-now"><span class="">get-now</span></a></li><li><a href="vertx.http.html#var-head"><span class="">head</span></a></li><li><a href="vertx.http.html#var-headers"><span class="">headers</span></a></li><li><a href="vertx.http.html#var-listen"><span class="">listen</span></a></li><li><a href="vertx.http.html#var-on-body"><span class="">on-body</span></a></li><li><a href="vertx.http.html#var-on-close"><span class="">on-close</span></a></li><li><a href="vertx.http.html#var-on-continue"><span class="">on-continue</span></a></li><li><a href="vertx.http.html#var-on-request"><span class="">on-request</span></a></li><li><a href="vertx.http.html#var-on-upload"><span class="">on-upload</span></a></li><li><a href="vertx.http.html#var-options"><span class="">options</span></a></li><li><a href="vertx.http.html#var-params"><span class="">params</span></a></li><li><a href="vertx.http.html#var-patch"><span class="">patch</span></a></li><li><a href="vertx.http.html#var-post"><span class="">post</span></a></li><li><a href="vertx.http.html#var-put"><span class="">put</span></a></li><li><a href="vertx.http.html#var-remote-address"><span class="">remote-address</span></a></li><li><a href="vertx.http.html#var-request"><span class="">request</span></a></li><li><a href="vertx.http.html#var-request-method"><span class="">request-method</span></a></li><li><a href="vertx.http.html#var-send-file"><span class="">send-file</span></a></li><li><a href="vertx.http.html#var-server"><span class="">server</span></a></li><li><a href="vertx.http.html#var-server-response"><span class="">server-response</span></a></li><li><a href="vertx.http.html#var-trace"><span class="">trace</span></a></li><li><a href="vertx.http.html#var-trailers"><span class="">trailers</span></a></li><li><a href="vertx.http.html#var-upload-file-info"><span class="">upload-file-info</span></a></li><li><a href="vertx.http.html#var-version"><span class="">version</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>vertx.http documentation</h2><pre class="doc">Provides a broad set of functions for creating HTTP servers and
clients, and handling requests.</pre><div class="public " id="var-add-header"><h3>add-header</h3><div class="usage"><code>(add-header req-or-resp key value)</code></div><pre class="doc">Sets an HTTP header on a client request or server response.
Key can be a string, keyword, or symbol. The latter two will be
converted to a string via name. Returns the request or response.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L207">Source</a></div></div><div class="public " id="var-add-headers"><h3>add-headers</h3><div class="usage"><code>(add-headers req-or-resp headers)</code></div><pre class="doc">Sets a HTTP headers on a client request or server response.
Keys can be strings, keywords, or symbols. The latter two will be
converted to strings via name. Returns the request or response.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L214">Source</a></div></div><div class="public " id="var-add-trailer"><h3>add-trailer</h3><div class="usage"><code>(add-trailer resp key value)</code></div><pre class="doc">Sets an HTTP trailer on a server response.
Key can be a string, keyword, or symbol. The latter two will be
converted to a string via name. Returns the request or response.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L223">Source</a></div></div><div class="public " id="var-add-trailers"><h3>add-trailers</h3><div class="usage"><code>(add-trailers req-or-resp trailers)</code></div><pre class="doc">Sets a HTTP trailers on a client request or server response.
Keys can be strings, keywords, or symbols. The latter two will be
converted to strings via name. Returns the request or response.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L230">Source</a></div></div><div class="public " id="var-client"><h3>client</h3><div class="usage"><code>(client)</code><code>(client properties)</code></div><pre class="doc">Creates a HTTP or HTTPS client (HttpClient) instance from vertx.core/*vertx*.
properties is a map of properties to set on the newly created
client instance. They are translated into .setXXX calls by
camel-casing the keyword key. Example: {:key-store-path
&quot;/some/path&quot;} will trigger a call to .setKeyStorePath on the
client object. See the documentation for
org.vertx.java.core.http.HttpClient for a full list of properties.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L348">Source</a></div></div><div class="public " id="var-close"><h3>close</h3><div class="usage"><code>(close server)</code><code>(close server handler)</code></div><pre class="doc">Close the server. Any open HTTP connections will be closed.
</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L105">Source</a></div></div><div class="public " id="var-connect"><h3>connect</h3><div class="usage"><code>(connect client uri handler)</code></div><pre class="doc">Creates a CONNECT HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full url is
provided, the host and port will be ignored, using the host and
port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. The request won't be issued until ended with
a call to the end function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L414">Source</a></div></div><div class="public " id="var-delete"><h3>delete</h3><div class="usage"><code>(delete client uri handler)</code></div><pre class="doc">Creates a DELETE HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full url is
provided, the host and port will be ignored, using the host and
port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. The request won't be issued until ended with
a call to the end function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L411">Source</a></div></div><div class="public " id="var-end"><h3>end</h3><div class="usage"><code>(end req-or-resp)</code><code>(end req-or-resp content)</code><code>(end req-or-resp content enc)</code></div><pre class="doc">Ends the server request or client response.
Writes the given content to the request or response before ending,
using the same rules as vertx.stream/write. If no data has been
written to the response body, the actual response won't get written
until this method gets called. Once the response has ended, it
cannot be used any more.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L332">Source</a></div></div><div class="public " id="var-expect-multi-part"><h3>expect-multi-part</h3><div class="usage"><code>(expect-multi-part req)</code></div><pre class="doc">Call this if you are expecting a multi-part form to be submitted in
the request. This must be called before the body of the request has
been received if you intend to call form-attributes.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L97">Source</a></div></div><div class="public " id="var-form-attributes"><h3>form-attributes</h3><div class="usage"><code>(form-attributes req)</code></div><pre class="doc">Returns a map of form-attributes for the request.
Keys will be keywords, and keys that have multiple values in the
attributes will have those values stored as a vector.  You will
need to call expect-multi-part on the request *before* reading the
body in order to use form-attributes.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L130">Source</a></div></div><div class="public " id="var-get"><h3>get</h3><div class="usage"><code>(get client uri handler)</code></div><pre class="doc">Creates a GET HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full url is
provided, the host and port will be ignored, using the host and
port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. The request won't be issued until ended with
a call to the end function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L408">Source</a></div></div><div class="public " id="var-get-now"><h3>get-now</h3><div class="usage"><code>(get-now client uri handler)</code><code>(get-now client uri headers handler)</code></div><pre class="doc">Creates a GET HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full
url is provided, the host and port will be ignored, using the host
and port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. This is a quick version of the get function,
used when you don't need to write a body to the request. This
request is immediately issued, and the end function need not be
called.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L376">Source</a></div></div><div class="public " id="var-head"><h3>head</h3><div class="usage"><code>(head client uri handler)</code></div><pre class="doc">Creates a HEAD HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full url is
provided, the host and port will be ignored, using the host and
port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. The request won't be issued until ended with
a call to the end function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L412">Source</a></div></div><div class="public " id="var-headers"><h3>headers</h3><div class="usage"><code>(headers req-or-resp)</code></div><pre class="doc">Returns a map of headers for the server request, server response, or client response.
Keys will be keywords, and keys that have multiple values in the
headers will have those values stored as a vector.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L174">Source</a></div></div><div class="public " id="var-listen"><h3>listen</h3><div class="usage"><code>(listen server port)</code><code>(listen server port host)</code><code>(listen server port host handler)</code></div><pre class="doc">Tells the server to start listening for connections on port.
If host is not provided, it defaults to &quot;0.0.0.0&quot;. handler can
either be a two-arity fn that will be passed the exception-map (if any)
and server from the result of the listen call, or a Handler
instance that will be called with the AsyncResult object that wraps
the exception and server. Returns the server instance.

Be aware this is an async operation and the server may not bound on
return of the function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L68">Source</a></div></div><div class="public " id="var-on-body"><h3>on-body</h3><div class="usage"><code>(on-body req-or-resp handler)</code></div><pre class="doc">Attach a handler to receive the entire body in one piece.
req-or-resp can either be a server request or client response.  handler
can either be a single-arity fn or a Handler instance that will be
passed the body as a buffer. This saves the user having to manually
set a data and end handler and append the chunks of the body until
the whole body received.  Don't use this if your request body is
large - you could potentially run out of RAM. Returns the given
server request or client response.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L188">Source</a></div></div><div class="public " id="var-on-close"><h3>on-close</h3><div class="usage"><code>(on-close resp handler)</code></div><pre class="doc">Attach a handler to be called if the request connection is closed before the response is complete.
handler can either be a zero-arity fn or a Handler instance that
will be called when the connection is closed.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L200">Source</a></div></div><div class="public " id="var-on-continue"><h3>on-continue</h3><div class="usage"><code>(on-continue req handler)</code></div><pre class="doc">Registers a continue handler on a HttpClientRequest.
handler can either be a zero-arity fn or a Handler instance that
will be called when the server is ready to continue.  If you send
an HTTP request with the Expect header set to the value
100-continue and the server responds with an interim HTTP response
with a status code of 100, then the handler will be called.  You
can then continue to write data to the request body and later end
it.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L420">Source</a></div></div><div class="public " id="var-on-request"><h3>on-request</h3><div class="usage"><code>(on-request server handler)</code></div><pre class="doc">Attaches a request handler to the server.
As HTTP requests are received by the server, instances of
HttpServerRequest will be created and passed to this
handler. handler can either be a single-arity fn or a Handler
instance that will be passed the request object. Returns the server
instance.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L87">Source</a></div></div><div class="public " id="var-on-upload"><h3>on-upload</h3><div class="usage"><code>(on-upload req handler)</code></div><pre class="doc">Set the upload handler on a server request.
The handler will get notified once a new file upload was received
and so allow to get notified by the upload in progress. handler can
either be a single-arity fn that will be passed a map of properties
of the uploaded file, or a Handler that will be called with the raw
HttpServerFileUpload object. See upload-file-info for more
information on the file properties. Returns the request.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L280">Source</a></div></div><div class="public " id="var-options"><h3>options</h3><div class="usage"><code>(options client uri handler)</code></div><pre class="doc">Creates a OPTIONS HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full url is
provided, the host and port will be ignored, using the host and
port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. The request won't be issued until ended with
a call to the end function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L413">Source</a></div></div><div class="public " id="var-params"><h3>params</h3><div class="usage"><code>(params req)</code></div><pre class="doc">Returns a map of parameters for the request.
Keys will be keywords, and keys that have multiple values in the
params will have those values stored as a vector.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L123">Source</a></div></div><div class="public " id="var-patch"><h3>patch</h3><div class="usage"><code>(patch client uri handler)</code></div><pre class="doc">Creates a PATCH HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full url is
provided, the host and port will be ignored, using the host and
port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. The request won't be issued until ended with
a call to the end function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L416">Source</a></div></div><div class="public " id="var-post"><h3>post</h3><div class="usage"><code>(post client uri handler)</code></div><pre class="doc">Creates a POST HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full url is
provided, the host and port will be ignored, using the host and
port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. The request won't be issued until ended with
a call to the end function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L410">Source</a></div></div><div class="public " id="var-put"><h3>put</h3><div class="usage"><code>(put client uri handler)</code></div><pre class="doc">Creates a PUT HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full url is
provided, the host and port will be ignored, using the host and
port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. The request won't be issued until ended with
a call to the end function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L409">Source</a></div></div><div class="public " id="var-remote-address"><h3>remote-address</h3><div class="usage"><code>(remote-address req)</code></div><pre class="doc">Returns the local address for the request as an address-map of the
form {:address &quot;127.0.0.1&quot; :port 8888 :basis inet-socket-address-object}</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L239">Source</a></div></div><div class="public " id="var-request"><h3>request</h3><div class="usage"><code>(request client method uri handler)</code></div><pre class="doc">Creates an HttpClientRequest object for the given HTTP method.
method should be one of: :OPTIONS, :GET, :HEAD, :POST, :PUT,
:DELETE, :TRACE, :CONNECT, or :PATCH. uri is the relative portion
of the url to be requested. If a full url is provided, the host and
port will be ignored, using the host and port set on the client
object instead. handler can either be a single-arity fn or a
Handler instance that will be passed the HttpClientResponse.  The
request won't be issued until ended with a call to the end
function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L363">Source</a></div></div><div class="public " id="var-request-method"><h3>request-method</h3><div class="usage"><code>(request-method req)</code></div><pre class="doc">Reads the HTTP request method from the request object as a keyword of the form :GET.
</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L119">Source</a></div></div><div class="public " id="var-send-file"><h3>send-file</h3><div class="usage"><code>(send-file resp filename &amp; {:keys [not-found handler]})</code></div><pre class="doc">Stream a file directly from disk to the outgoing connection.
This bypasses userspace altogether where supported by
the underlying operating system. This is a very efficient way to
serve files. Takes the following keyword arguments:

:not-found  The path to a resource to serve if filename is
            not found. If not-found is not specified, a standard
            404 responses is generated.
:handler    can either be a single-arity fn that will be passed the
            exception-map (if any) from the result of the send-file
            call, or a org.vertx.java.core.Handler that will be
            called with the AsyncResult object that wraps the
            exception

Returns the response object.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L291">Source</a></div></div><div class="public " id="var-server"><h3>server</h3><div class="usage"><code>(server)</code><code>(server properties)</code></div><pre class="doc">Creates a HTTP or HTTPS server (HttpServer) instance from vertx.core/*vertx*.
properties is a map of properties to set on the newly created
server instance. They are translated into .setXXX calls by
camel-casing the keyword key. Example: {:key-store-path
&quot;/some/path&quot;} will trigger a call to .setKeyStorePath on the
server object. See the documentation for
org.vertx.java.core.http.HttpServer for a full list of properties.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L54">Source</a></div></div><div class="public " id="var-server-response"><h3>server-response</h3><div class="usage"><code>(server-response req)</code><code>(server-response req properties)</code></div><pre class="doc">Creates a response object for the given request object.
Properties is a map of options for the server instance. They are
translated into .setXXX calls by camel-casing the keyword
key. Example: {:status-code 418} will trigger a call to
.setStatusCode on the response object. See the documentation for
org.vertx.java.core.http.HttpServerResponse for a full list of
properties.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L245">Source</a></div></div><div class="public " id="var-trace"><h3>trace</h3><div class="usage"><code>(trace client uri handler)</code></div><pre class="doc">Creates a TRACE HttpClientRequest object.
uri is the relative portion of the url to be requested. If a full url is
provided, the host and port will be ignored, using the host and
port set on the client object instead. handler can either be a
single-arity fn or a Handler instance that will be passed the
HttpClientResponse. The request won't be issued until ended with
a call to the end function.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L415">Source</a></div></div><div class="public " id="var-trailers"><h3>trailers</h3><div class="usage"><code>(trailers req-or-resp)</code></div><pre class="doc">Returns a map of trailers for the server response or client response.
Keys will be keywords, and keys that have multiple values in the
trailers will have those values stored as a vector.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L181">Source</a></div></div><div class="public " id="var-upload-file-info"><h3>upload-file-info</h3><div class="usage"><code>(upload-file-info file)</code></div><pre class="doc">Takes an HttpServerFileUpload object, and returns a map of properties about that object.

The properties are:
* :filename     - the name of the file
* :name         - the name of the upload attribute
* :content-type - the content-type specified in the upload
* :encoding     - the content transfer encoding
* :size         - the size of the file in bytes
* :charset      - the Charset as a String
* :basis        - the original file object, which is also a ReadStream
* :save-fn      - a single-arity fn that can be passed a path to save the file to disk</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L258">Source</a></div></div><div class="public " id="var-version"><h3>version</h3><div class="usage"><code>(version req)</code></div><pre class="doc">Reads the HTTP version from the request object as a String of the form &quot;HTTP/1.1&quot;.
</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/http.clj#L113">Source</a></div></div></div></body></html>