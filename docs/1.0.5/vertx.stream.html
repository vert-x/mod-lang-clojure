<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>vertx.stream documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Vert.x clojure language module  API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="vertx.buffer.html"><span>vertx.buffer</span></a></li><li><a href="vertx.core.html"><span>vertx.core</span></a></li><li><a href="vertx.datagram.html"><span>vertx.datagram</span></a></li><li><a href="vertx.dns.html"><span>vertx.dns</span></a></li><li><a href="vertx.embed.html"><span>vertx.embed</span></a></li><li><a href="vertx.embed.platform.html"><span>vertx.embed.platform</span></a></li><li><a href="vertx.eventbus.html"><span>vertx.eventbus</span></a></li><li><a href="vertx.filesystem.html"><span>vertx.filesystem</span></a></li><li><a href="vertx.filesystem.sync.html"><span>vertx.filesystem.sync</span></a></li><li><a href="vertx.http.html"><span>vertx.http</span></a></li><li><a href="vertx.http.route.html"><span>vertx.http.route</span></a></li><li><a href="vertx.http.sockjs.html"><span>vertx.http.sockjs</span></a></li><li><a href="vertx.http.websocket.html"><span>vertx.http.websocket</span></a></li><li><a href="vertx.logging.html"><span>vertx.logging</span></a></li><li><a href="vertx.net.html"><span>vertx.net</span></a></li><li><a href="vertx.repl.html"><span>vertx.repl</span></a></li><li><a href="vertx.shareddata.html"><span>vertx.shareddata</span></a></li><li class="current"><a href="vertx.stream.html"><span>vertx.stream</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="vertx.stream.html#var-on-data"><span class="">on-data</span></a></li><li><a href="vertx.stream.html#var-on-drain"><span class="">on-drain</span></a></li><li><a href="vertx.stream.html#var-on-end"><span class="">on-end</span></a></li><li><a href="vertx.stream.html#var-on-exception"><span class="">on-exception</span></a></li><li><a href="vertx.stream.html#var-pump"><span class="">pump</span></a></li><li><a href="vertx.stream.html#var-write"><span class="">write</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>vertx.stream documentation</h2><pre class="doc">Functions that operate on Vert.x ReadStreams and WriteStreams.
</pre><div class="public " id="var-on-data"><h3>on-data</h3><div class="usage"><code>(on-data stream handler)</code></div><pre class="doc">Set a data handler on a ReadStream.
As data is read, the handler will be called with the data as a Buffer.
handler can either be a Handler or a single-arity fn.
Returns the stream.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/stream.clj#L22">Source</a></div></div><div class="public " id="var-on-drain"><h3>on-drain</h3><div class="usage"><code>(on-drain stream handler)</code></div><pre class="doc">Set a drain handler on a WriteStream.
If the write queue is full, then the handler will be called when
the write queue has been reduced to maxSize / 2.
handler can either be a Handler or a zero-arity fn.
Returns the stream.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/stream.clj#L30">Source</a></div></div><div class="public " id="var-on-end"><h3>on-end</h3><div class="usage"><code>(on-end stream handler)</code></div><pre class="doc">Set an end handler on a ReadStream.
Once the stream has ended, and there is no more data to be read,
this handler will be called.
handler can either be a Handler or a zero-arity fn.
Returns the stream.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/stream.clj#L39">Source</a></div></div><div class="public " id="var-on-exception"><h3>on-exception</h3><div class="usage"><code>(on-exception stream handler)</code></div><pre class="doc">Set an exception handler on a stream.
handler can either be a Handler or a single-arity fn that will be
passed the exception.
Returns the stream.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/stream.clj#L48">Source</a></div></div><div class="public " id="var-pump"><h3>pump</h3><div class="usage"><code>(pump read-stream write-stream)</code><code>(pump read-stream write-stream start?)</code></div><pre class="doc">Creates a Pump instance.

A Pump pumps data from a ReadStream to a WriteStream and performs
flow control where necessary to prevent the write stream buffer
from getting overfull.

Read bytes from a ReadStream and writes them to a WriteStream. If
data can be read faster than it can be written this could result in
the write queue of the WriteStream growing without bound,
eventually causing it to exhaust all available RAM.

To prevent this, after each write, it checks whether the write
queue of the WriteStream is full, and if so, the ReadStream is
paused, and a drainHandler is set on the WriteStream. When the
WriteStream has processed half of its backlog, the
drainHandler will be called, which results in the pump resuming
the ReadStream.

If start? is true (the default), the Pump will be started.</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/stream.clj#L64">Source</a></div></div><div class="public " id="var-write"><h3>write</h3><div class="usage"><code>(write stream data)</code><code>(write stream data-str enc)</code></div><pre class="doc">Write data to the stream.
data can anything bufferable (see vertx.buffer).</pre><div class="src-link"><a href="https://github.com/vert-x/mod-lang-clojure/tree/master/api/src/main/clojure/vertx/stream.clj#L56">Source</a></div></div></div></body></html>